diff --git a/typer/discovery.py b/typer/discovery.py new file mode 100644 index 0000000..ac76089 --- /dev/null +++ b/typer/discovery.py @@ -0,0 +1,220 @@ +from __future__ import annotations + +import importlib +import pkgutil +from fnmatch import fnmatchcase +from types import ModuleType +from typing import Dict, List, Optional, Sequence, Tuple, Set + +import typer +from typer.main import get_command_name +from typer.models import CommandInfo, DefaultPlaceholder, TyperInfo + + +class TyperDiscoveryError(Exception): +    pass + + +_REGISTRY_ATTR = "_typer_discovery_registered" +_NS_ATTR = "_typer_discovery_namespaces" + + +def _registered_command_names(app: typer.Typer) -> Set[str]: +    names: Set[str] = set() +    for info in app.registered_commands: +        if isinstance(info, CommandInfo): +            # Explicit name +            if info.name and not isinstance(info.name, DefaultPlaceholder): +                names.add(info.name) +                continue +            # Derived from callback +            if info.callback: +                names.add(get_command_name(info.callback.__name__)) +    return names + + +def _resolve_group_name(group: TyperInfo) -> Optional[str]: +    raw_name = group.name +    if isinstance(raw_name, DefaultPlaceholder): +        raw_name = raw_name.value +    if raw_name: +        return raw_name +    # fallback to instance.info.name if available +    instance = group.typer_instance +    try: +        instance_name = instance.info.name  # type: ignore[attr-defined] +        if isinstance(instance_name, DefaultPlaceholder): +            instance_name = instance_name.value +        if isinstance(instance_name, str) and instance_name: +            return instance_name +    except AttributeError: +        pass +    return None + + +def _registered_group_names(app: typer.Typer) -> Set[str]: +    names: Set[str] = set() +    for group in app.registered_groups: +        if isinstance(group, TyperInfo): +            name = _resolve_group_name(group) +            if name: +                names.add(name) +    return names + + +def _existing_names(app: typer.Typer) -> Set[str]: +    return _registered_command_names(app) | _registered_group_names(app) + + +def _pattern_matches(relname: str, pattern: str) -> bool: +    # Support simple globbing and the special semantics that "pkg.*" matches +    # both "pkg" and all its descendants. +    if pattern.endswith(".*"): +        base = pattern[:-2] +        return relname == base or relname.startswith(base + ".") +    # Fallback to standard glob semantics +    return fnmatchcase(relname, pattern) + + +def _should_include(relname: str, filters: Optional[Sequence[str]]) -> bool: +    if not filters: +        return True +    for p in filters: +        if _pattern_matches(relname, p): +            return True +    return False + + +def _ensure_registry(app: typer.Typer) -> set: +    reg = getattr(app, _REGISTRY_ATTR, None) +    if reg is None: +        reg = set() +        setattr(app, _REGISTRY_ATTR, reg) +    return reg + + +def _ensure_ns_map(app: typer.Typer) -> Dict[str, typer.Typer]: +    ns = getattr(app, _NS_ATTR, None) +    if ns is None: +        ns = {} +        setattr(app, _NS_ATTR, ns) +    return ns + + +def _get_or_create_namespace(app: typer.Typer, name: str) -> typer.Typer: +    ns_map = _ensure_ns_map(app) +    if name in ns_map: +        return ns_map[name] + +    # If a command with the same name already exists and wasn't created by discovery, +    # we surface a collision. +    existing = _existing_names(app) +    if name in existing and name not in _ensure_registry(app): +        raise TyperDiscoveryError(f"Name collision registering namespace '{name}'") + +    ns_app = typer.Typer() +    app.add_typer(ns_app, name=name) +    ns_map[name] = ns_app +    # Track this synthetic command to support idempotency. +    _ensure_registry(app).add(name) +    return ns_app + + +def register_package( +    app: typer.Typer, +    package: ModuleType, +    *, +    namespace: Optional[str] = None, +    filters: Optional[Sequence[str]] = None, +) -> None: +    """Discover Typer apps named `app` within a package and register them. + +    - Respects optional glob `filters` matched against dotted paths relative to the package +      (e.g. "users", "inventory.*"). A pattern ending in ".*" matches the package itself +      and all its descendants. +    - If `namespace` is provided, discovered groups are added under that group. +    - Raises TyperDiscoveryError on import failures or name collisions with existing commands. +    - Idempotent: re-running does not duplicate commands. +    """ + +    if not hasattr(package, "__path__"): +        # Not a package +        return + +    prefix = package.__name__ + "." + +    # Collect candidate module names without importing them yet. +    candidates: List[Tuple[str, bool]] = []  # (fullname, is_pkg) +    for modinfo in pkgutil.walk_packages(package.__path__, prefix=prefix): +        name = modinfo.name +        is_pkg = modinfo.ispkg +        relname = name[len(prefix) :] +        if _should_include(relname, filters): +            candidates.append((name, is_pkg)) +        elif filters: +            # Special case: if a filter like "pkg.*" matches a descendant, ensure parent +            # packages are included when they define an app. We'll import parents on demand +            # later when wiring children. +            pass + +    # Also include any parent package modules required by filters that target submodules. +    if filters: +        # Build set of explicit relnames we're including +        rel_includes = {fullname[len(prefix) :] for fullname, _ in candidates} +        for p in filters: +            if p.endswith(".*"): +                base = p[:-2] +                # Include the base package itself +                if base and base not in rel_includes: +                    candidates.append((prefix + base, True)) + +    # Import in topological order: parents first. +    candidates.sort(key=lambda t: t[0].count(".")) + +    # Import modules and collect their Typer apps +    discovered: Dict[str, typer.Typer] = {} +    for fullname, _ in candidates: +        relname = fullname[len(prefix) :] +        try: +            mod = importlib.import_module(fullname) +        except Exception as exc:  # noqa: BLE001 - surface controlled error +            raise TyperDiscoveryError(f"Failed to import module '{fullname}'") from exc + +        app_obj = getattr(mod, "app", None) +        if isinstance(app_obj, typer.Typer): +            discovered[relname] = app_obj + +    # Nothing to register +    if not discovered: +        return + +    # Determine root parent where groups will be attached +    parent_app = app if namespace is None else _get_or_create_namespace(app, namespace) + +    # Register discovered apps hierarchically +    for relname in sorted(discovered.keys(), key=lambda n: n.count(".")): +        parts = relname.split(".") +        group_name = parts[-1] +        # find parent container +        if len(parts) == 1: +            container = parent_app +        else: +            parent_rel = ".".join(parts[:-1]) +            container = discovered.get(parent_rel) +            if container is None: +                # Parent doesn't define an app; attach to parent_app directly +                container = parent_app + +        # Idempotency/collision handling at this container level +        existing = _existing_names(container) +        reg = _ensure_registry(container) +        if group_name in existing: +            # If previously registered by discovery, skip (idempotent). Otherwise, collision. +            if group_name in reg: +                continue +            raise TyperDiscoveryError( +                f"Name collision registering command '{group_name}'" +            ) + +        container.add_typer(discovered[relname], name=group_name) +        reg.add(group_name)